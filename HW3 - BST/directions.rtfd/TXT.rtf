{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red47\green102\blue178;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl300\partightenfactor0

\f0\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Your program should begin by asking the user for a local file to read. (You may want to copy this file to a local file for testing purposes:{\field{\*\fldinst{HYPERLINK "http://www.gutenberg.org/cache/epub/1342/pg1342.txt"}}{\fldrslt \cf4 \strokec4 http://www.gutenberg.org/cache/epub/1342/pg1342.txt}} ). \
\
As your program reads in words, it will remove all non-alphabetic characters (including punctuation and digits) and change any capitalized character into lower-case format. A word is defined as a sequence of characters separated by white spaces and new lines.\
\
\
Thus, "Darcy's" becomes the word "darcys".\
\
This sentence fragment (from near the end of chapter 4 of the above file):\
\
\pard\pardeftab720\sl300\partightenfactor0

\i \cf2 Mrs. Hurst and her sister allowed it to be so--but still they admired her
\i0 \
\
becomes the sequence of words\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 mrs (period and capitalization removed)\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 hurst (capitalization removed)\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 and\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 her\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 sister\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 allowed\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 it\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 to\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 be\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 sobut (note that the dash marks are removed, so this becomes one word)\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 still\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 they\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 admired\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 her\cb1 \
\pard\pardeftab720\sl300\partightenfactor0
\cf2 \cb3 You should define a new class BST that implements a binary search tree. Please design and implement the following methods (
\i \ul we will start doing this together in lab
\i0 \ulnone ). You can include additional methods if you think it is appropriate:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 __init__\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 size (giving the number of entries in the tree)\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 height (giving the depth of the tree)\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 find(word) - this performs a binary search to see if the word is in the tree, if so, returns the number of times the word appears in the input text file\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 add(word) -- if the word is not already in the tree, this adds it with an initial count of one. If the word is present, this increments it by one\cb1 \
\pard\pardeftab720\sl300\partightenfactor0
\cf2 \cb3 find(word) and add(word) should be fully recursive functions. Each node in the tree may keep track of the depth of the current subtree and the number of entries below it\
\
After the work is loaded into the dictionary, the program should run a main loop that takes as input a test word, and finds if it is in the BST. The format should look 
\i exactly
\i0  like this\
\pard\pardeftab720\sl300\partightenfactor0

\f1 \cf2 Query? elizabeth 
\f0 \

\f1 The word elizabeth appears XXX times in the tree 
\f0 \
If the key word "
\f1 stats
\f0 " is given, the program should print out the number of entries in the tree and the maximum depth of the tree.\
\
If the key word "
\f1 terminate
\f0 " is given, the program should terminate.\
\
Answer the following questions and include the answers in a README file:\
(1) For the file {\field{\*\fldinst{HYPERLINK "http://www.gutenberg.org/cache/epub/1342/pg1342.txt"}}{\fldrslt \cf4 \strokec4 http://www.gutenberg.org/cache/epub/1342/pg1342.txt}} what is the depth of your tree? What does that say about the number of operations to find a word?\
(2) What would happen if the input to your program were sorted (as it was in HW 1)?\
(3) What are applications for binary search tree? In what ways are they superior to lists? In what ways are they inferior to lists?\
(4) Did you implement the extra credit (listed below)? If so please explain your testing strategy on the extra credit.\
\pard\pardeftab720\sl300\partightenfactor0
\cf2 \
Extra credit: For extra credit, modify "add(word)" so that as it adds words to the tree, it keeps the tree balanced through tree rotation, so that every leaf node differs by at most one in depth. See {\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Tree_rotation"}}{\fldrslt \cf4 \strokec4 http://en.wikipedia.org/wiki/Tree_rotation}} for details.\
\
Please extensively test your assignment. We will cover testing scripts in lab section. \
In your README file, also explain how you tested your program (what test cases and strategies did you use) and don't forget the answers to the questions above. You will turn in the following files.\
hw3.py\
BST.py\
test.py\
README.txt\
Upload these files using the file upload tool available at:: {\field{\*\fldinst{HYPERLINK "https://www.ischool.berkeley.edu/uploader/?s=i206"}}{\fldrslt \cf4 \strokec4 https://www.ischool.berkeley.edu/uploader/?s=i206}} . Login with your ISchool userid and password and follow the directions.}